clc, clear, close all;
%%
addpath("D:\tuan\analysis\analysis_fringe");

[groundtruth, pos_coeff, val_coeff] = create_random_zernike_surface();
hologram = create_hologram(groundtruth, 0.1);
figure;
surf(groundtruth, "EdgeColor","none");
title("groundtruth");
figure;
imshow(hologram,[]);
title("anh hologram");

[estimate_phase, wrapped_phase] = create_estimate_phase(hologram, groundtruth);
figure;
surf(groundtruth, "EdgeColor","none");
title("estimate phase");

% 3.3 Chạy unwrapping
% --- Unwrap phase bằng các thuật toán ---
phi_tie_dct      = Unwrap_TIE_DCT_Iter(wrapped_phase);     % TIE với DCT
phi_quality      = unwrap_quality(wrapped_phase);          % Quality-guided
phi_wls          = phase_unwrap_2dweight(wrapped_phase);      % 2D Weighted LS
phi_proposed     = estimate_phase;                                     % Proposed / Hybrid
phi_goldstein    = unwrap_goldstein(wrapped_phase);     % goldstein branch-cut

% --- Crop tất cả về cùng kích thước nhỏ nhất ---
[groundtruth, wrapped_phase, phi_goldstein, phi_tie_dct, phi_quality, phi_wls, phi_proposed] = ...
    crop_multiple_to_smallest(groundtruthwrapped_phase, phi_goldstein, phi_tie_dct, phi_quality, phi_wls, phi_proposed);

phi_GT = groundtruth;
% 3.4 Tính sai số
RMSE(k,1) = compute_rmse(phi_est_prop, phi_GT);
RMSE(k,2) = compute_rmse(phi_est_gold, phi_GT);
RMSE(k,3) = compute_rmse(phi_est_qg,   phi_GT);
RMSE(k,4) = compute_rmse(phi_est_fly,  phi_GT);
RMSE(k,5) = compute_rmse(phi_est_ls,   phi_GT);

% 3.5 Lưu hình (optional)
if params.save_each
    show_results(phi_GT, phi_noisy, phi_est_prop, k);
end

% 4. Tổng hợp kết quả
mean_RMSE = mean(RMSE);
std_RMSE  = std(RMSE);

% 5. Vẽ biểu đồ so sánh
figure; bar(mean_RMSE); title("Average RMSE over K samples");


function varargout = crop_multiple_to_smallest(varargin)
% Giả định tất cả các biến là 2D ma trận
n = nargin;
sizes = cellfun(@size, varargin, 'UniformOutput', false);

% Tìm kích thước nhỏ nhất theo từng chiều
min_rows = min(cellfun(@(s) s(1), sizes));
min_cols = min(cellfun(@(s) s(2), sizes));

varargout = cell(1, n);
for i = 1:n
    mat = varargin{i};
    [m, n_] = size(mat);

    % Tính chỉ số cắt đều 4 phía
    row_start = floor((m - min_rows)/2) + 1;
    col_start = floor((n_ - min_cols)/2) + 1;
    row_end = row_start + min_rows - 1;
    col_end = col_start + min_cols - 1;

    varargout{i} = mat(row_start:row_end, col_start:col_end);
end
end

